#!/bin/bash

#############################################################################
#  ______     _     _     _            __     _______                       #
# |___  /    | |   | |   (_)           \ \   |__   __|                      #
#    / / __ _| |__ | |__  ___  __  _____\ \     | | ___  __ _ _ __ ___  ___ #
#   / / / _` | '_ \| '_ \| \ \/ / |______> >    | |/ _ \/ _` | '_ ` _ \/ __|#
#  / /_| (_| | |_) | |_) | |>  <        / /     | |  __/ (_| | | | | | \__ \#
# /_____\__,_|_.__/|_.__/|_/_/\_\      /_/      |_|\___|\__,_|_| |_| |_|___/#
#############################################################################

# Title: zabbix-teams.sh
# Author: Jared Brogan
# Purpose: Integrate Zabbix alerts into Microsoft Teams

# Example webhook test message:
#   WEBHOOK_URL=
#   ./zabbix-teams.sh "${WEBHOOK_URL}" "HOST GROUP: Acknowledged - Test Alert" "Test message"

## Values received by this script:
# WebHook = $1 (URL generated by configuring an incoming webhook on a specific Teams channel. This should be configured as a user's media on Zabbix frontend.)
# Subject = $2 (usually contains either PROBLEM or Resolved/OK)
# Message = $3 (whatever message the Zabbix action sends, preferably something like "Zabbix server is unreachable for 5 minutes - Zabbix server (127.0.0.1)")

webhook_url="$1"
subject="$2"
message="$(echo "$3" | egrep -v '(ACK_URL|PROB_URL)')"
prob_url="$(echo "$3" | grep PROB_URL | sed 's/PROB_URL: //g ; s/ .*//g')"
ack_url="$(echo "$3" | grep ACK_URL | sed 's/ACK_URL: //g ; s/ .*//g')"

###############################################################################

# Payload formatted for PROBLEM issues
read -r -d '' problem_payload <<- EOM
{
"@context": "http://schema.org/extensions",
"@type": "MessageCard",
"themeColor": "EA4300",
"title": "${subject}",
"text": "${message}",
"potentialAction": [
  {
    "@type": "OpenUri",
    "name": "Details",
    "targets": [
      { "os": "default", "uri": "${prob_url}" }
    ]
  },
  {
    "@type": "OpenUri",
    "name": "Acknowledge",
    "targets": [
      { "os": "default", "uri": "${ack_url}" }
    ]
  }
]
}
EOM

###############################################################################

# Payload formatted for RESOLVED issues
read -r -d '' resolved_payload <<- EOM
{
"@context": "http://schema.org/extensions",
"@type": "MessageCard",
"themeColor": "43EA00",
"title": "${subject}",
"text": "${message}",
"potentialAction": [
  {
    "@type": "OpenUri",
    "name": "Details",
    "targets": [
      { "os": "default", "uri": "${prob_url}" }
    ]
  }
]
}
EOM

###############################################################################

# payload formatted for RESOLVED issues
read -r -d '' ack_payload <<- EOM
{
"@context": "http://schema.org/extensions",
"@type": "MessageCard",
"themeColor": "0072C6",
"title": "${subject}",
"text": "${message}",
"potentialAction": [
  {
    "@type": "OpenUri",
    "name": "Details",
    "targets": [
      { "os": "default", "uri": "${prob_url}" }
    ]
  }
]
}
EOM

###############################################################################

# Decide which payload to send to the webhook
if [[ $(echo "$subject" | egrep -qi '(problem)' ; echo $?) -eq 0 ]]; then
        payload="${problem_payload}"
elif [[ $(echo "$subject" | egrep -qi '(resolved|ok)' ; echo $?) -eq 0 ]]; then
        payload="${resolved_payload}"
elif [[ $(echo "$subject" | egrep -qi '(acknowledged)' ; echo $?) -eq 0 ]]; then
        payload="${ack_payload}"
fi

curl -sSL -H "Content-Type: application/json" -d "${payload}" $webhook_url
